#include "kcc.h"

CodeGenerator *codegen_create(const char *output_filename) {
    CodeGenerator *codegen = malloc(sizeof(CodeGenerator));
    if (!codegen) {
        error_fatal("Memory allocation failed for code generator");
        return NULL;
    }
    
    codegen->output_file = fopen(output_filename, "w");
    if (!codegen->output_file) {
        free(codegen);
        error_fatal("Could not open output file '%s'", output_filename);
        return NULL;
    }
    
    codegen->label_counter = 0;
    codegen->temp_counter = 0;
    
    return codegen;
}

void codegen_destroy(CodeGenerator *codegen) {
    if (codegen) {
        if (codegen->output_file) {
            fclose(codegen->output_file);
        }
        free(codegen);
    }
}

void codegen_emit(CodeGenerator *codegen, const char *format, ...) {
    va_list args;
    va_start(args, format);
    vfprintf(codegen->output_file, format, args);
    va_end(args);
    fprintf(codegen->output_file, "\n");
}

char *codegen_new_label(CodeGenerator *codegen) {
    char *label = malloc(32);
    if (!label) {
        error_fatal("Memory allocation failed for label");
        return NULL;
    }
    snprintf(label, 32, "L%d", codegen->label_counter++);
    return label;
}

char *codegen_new_temp(CodeGenerator *codegen) {
    char *temp = malloc(32);
    if (!temp) {
        error_fatal("Memory allocation failed for temp");
        return NULL;
    }
    snprintf(temp, 32, "t%d", codegen->temp_counter++);
    return temp;
}

bool codegen_generate(CodeGenerator *codegen, ASTNode *ast) {
    if (!codegen || !ast) {
        return false;
    }
    
    // Generate assembly header
    codegen_emit(codegen, "# Generated by KCC (Kayte C Compiler) v%s", KCC_VERSION);
    codegen_emit(codegen, ".text");
    codegen_emit(codegen, ".global _start");
    codegen_emit(codegen, "");
    
    // Generate code for the program
    codegen_program(codegen, ast);
    
    // Generate basic exit code
    codegen_emit(codegen, "");
    codegen_emit(codegen, "_start:");
    codegen_emit(codegen, "    call main");
    codegen_emit(codegen, "    mov $60, %%rax  # sys_exit");
    codegen_emit(codegen, "    mov $0, %%rdi   # exit status");
    codegen_emit(codegen, "    syscall");
    
    return true;
}

void codegen_program(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_PROGRAM) return;
    
    for (int i = 0; i < node->data.program.declaration_count; i++) {
        ASTNode *decl = node->data.program.declarations[i];
        
        if (decl->type == AST_FUNCTION_DECL) {
            codegen_function_declaration(codegen, decl);
        } else if (decl->type == AST_VAR_DECL) {
            codegen_variable_declaration(codegen, decl);
        }
    }
}

void codegen_function_declaration(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_FUNCTION_DECL) return;
    
    codegen_emit(codegen, "");
    codegen_emit(codegen, "# Function: %s", node->data.function_decl.name);
    codegen_emit(codegen, "%s:", node->data.function_decl.name);
    
    // Function prologue
    codegen_emit(codegen, "    push %%rbp");
    codegen_emit(codegen, "    mov %%rsp, %%rbp");
    
    // Generate function body
    if (node->data.function_decl.body) {
        codegen_compound_statement(codegen, node->data.function_decl.body);
    }
    
    // Function epilogue (in case there's no explicit return)
    codegen_emit(codegen, "    mov %%rbp, %%rsp");
    codegen_emit(codegen, "    pop %%rbp");
    codegen_emit(codegen, "    ret");
}

void codegen_variable_declaration(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_VAR_DECL) return;
    
    codegen_emit(codegen, "# Variable: %s", node->data.var_decl.name);
    
    if (node->data.var_decl.initializer) {
        // Generate code for initializer
        codegen_expression(codegen, node->data.var_decl.initializer);
        // Store the result in the variable (simplified)
        codegen_emit(codegen, "    # Store result in %s", node->data.var_decl.name);
    }
}

void codegen_statement(CodeGenerator *codegen, ASTNode *node) {
    switch (node->type) {
        case AST_COMPOUND_STMT:
            codegen_compound_statement(codegen, node);
            break;
        case AST_EXPRESSION_STMT:
            codegen_expression_statement(codegen, node);
            break;
        case AST_RETURN_STMT:
            codegen_return_statement(codegen, node);
            break;
        case AST_IF_STMT:
            codegen_if_statement(codegen, node);
            break;
        case AST_WHILE_STMT:
            codegen_while_statement(codegen, node);
            break;
        case AST_FOR_STMT:
            codegen_for_statement(codegen, node);
            break;
        case AST_VAR_DECL:
            codegen_variable_declaration(codegen, node);
            break;
        default:
            codegen_emit(codegen, "    # Unsupported statement type: %s", 
                        ast_node_type_to_string(node->type));
            break;
    }
}

void codegen_compound_statement(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_COMPOUND_STMT) return;
    
    for (int i = 0; i < node->data.compound_stmt.statement_count; i++) {
        codegen_statement(codegen, node->data.compound_stmt.statements[i]);
    }
}

void codegen_expression_statement(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_EXPRESSION_STMT) return;
    
    if (node->data.expression_stmt.expression) {
        codegen_expression(codegen, node->data.expression_stmt.expression);
    }
}

void codegen_return_statement(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_RETURN_STMT) return;
    
    if (node->data.return_stmt.expression) {
        codegen_expression(codegen, node->data.return_stmt.expression);
        codegen_emit(codegen, "    # Move result to %%rax for return");
    } else {
        codegen_emit(codegen, "    mov $0, %%rax  # Return 0");
    }
    
    // Function epilogue
    codegen_emit(codegen, "    mov %%rbp, %%rsp");
    codegen_emit(codegen, "    pop %%rbp");
    codegen_emit(codegen, "    ret");
}

void codegen_if_statement(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_IF_STMT) return;
    
    char *else_label = codegen_new_label(codegen);
    char *end_label = codegen_new_label(codegen);
    
    // Generate condition
    codegen_expression(codegen, node->data.if_stmt.condition);
    codegen_emit(codegen, "    test %%rax, %%rax");
    codegen_emit(codegen, "    jz %s", else_label);
    
    // Generate then statement
    codegen_statement(codegen, node->data.if_stmt.then_stmt);
    codegen_emit(codegen, "    jmp %s", end_label);
    
    // Generate else statement (if present)
    codegen_emit(codegen, "%s:", else_label);
    if (node->data.if_stmt.else_stmt) {
        codegen_statement(codegen, node->data.if_stmt.else_stmt);
    }
    
    codegen_emit(codegen, "%s:", end_label);
    
    free(else_label);
    free(end_label);
}

void codegen_while_statement(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_WHILE_STMT) return;
    
    char *loop_label = codegen_new_label(codegen);
    char *end_label = codegen_new_label(codegen);
    
    codegen_emit(codegen, "%s:", loop_label);
    
    // Generate condition
    codegen_expression(codegen, node->data.while_stmt.condition);
    codegen_emit(codegen, "    test %%rax, %%rax");
    codegen_emit(codegen, "    jz %s", end_label);
    
    // Generate body
    codegen_statement(codegen, node->data.while_stmt.body);
    codegen_emit(codegen, "    jmp %s", loop_label);
    
    codegen_emit(codegen, "%s:", end_label);
    
    free(loop_label);
    free(end_label);
}

void codegen_for_statement(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_FOR_STMT) return;
    
    char *loop_label = codegen_new_label(codegen);
    char *update_label = codegen_new_label(codegen);
    char *end_label = codegen_new_label(codegen);
    
    // Generate initialization
    if (node->data.for_stmt.init) {
        codegen_expression(codegen, node->data.for_stmt.init);
    }
    
    codegen_emit(codegen, "%s:", loop_label);
    
    // Generate condition
    if (node->data.for_stmt.condition) {
        codegen_expression(codegen, node->data.for_stmt.condition);
        codegen_emit(codegen, "    test %%rax, %%rax");
        codegen_emit(codegen, "    jz %s", end_label);
    }
    
    // Generate body
    codegen_statement(codegen, node->data.for_stmt.body);
    
    // Generate update
    codegen_emit(codegen, "%s:", update_label);
    if (node->data.for_stmt.update) {
        codegen_expression(codegen, node->data.for_stmt.update);
    }
    codegen_emit(codegen, "    jmp %s", loop_label);
    
    codegen_emit(codegen, "%s:", end_label);
    
    free(loop_label);
    free(update_label);
    free(end_label);
}

void codegen_expression(CodeGenerator *codegen, ASTNode *node) {
    switch (node->type) {
        case AST_BINARY_EXPR:
            codegen_binary_expression(codegen, node);
            break;
        case AST_UNARY_EXPR:
            codegen_unary_expression(codegen, node);
            break;
        case AST_CALL_EXPR:
            codegen_call_expression(codegen, node);
            break;
        case AST_IDENTIFIER:
            codegen_identifier(codegen, node);
            break;
        case AST_NUMBER:
            codegen_number(codegen, node);
            break;
        case AST_STRING:
            codegen_string(codegen, node);
            break;
        case AST_ASSIGNMENT:
            codegen_assignment(codegen, node);
            break;
        default:
            codegen_emit(codegen, "    # Unsupported expression type: %s", 
                        ast_node_type_to_string(node->type));
            break;
    }
}

void codegen_binary_expression(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_BINARY_EXPR) return;
    
    // Generate left operand
    codegen_expression(codegen, node->data.binary_expr.left);
    codegen_emit(codegen, "    push %%rax");
    
    // Generate right operand
    codegen_expression(codegen, node->data.binary_expr.right);
    codegen_emit(codegen, "    mov %%rax, %%rbx");
    codegen_emit(codegen, "    pop %%rax");
    
    // Generate operation
    switch (node->data.binary_expr.operator) {
        case TOKEN_PLUS:
            codegen_emit(codegen, "    add %%rbx, %%rax");
            break;
        case TOKEN_MINUS:
            codegen_emit(codegen, "    sub %%rbx, %%rax");
            break;
        case TOKEN_MULTIPLY:
            codegen_emit(codegen, "    imul %%rbx, %%rax");
            break;
        case TOKEN_DIVIDE:
            codegen_emit(codegen, "    cqo");
            codegen_emit(codegen, "    idiv %%rbx");
            break;
        case TOKEN_EQUAL:
            codegen_emit(codegen, "    cmp %%rbx, %%rax");
            codegen_emit(codegen, "    sete %%al");
            codegen_emit(codegen, "    movzb %%al, %%rax");
            break;
        case TOKEN_NOT_EQUAL:
            codegen_emit(codegen, "    cmp %%rbx, %%rax");
            codegen_emit(codegen, "    setne %%al");
            codegen_emit(codegen, "    movzb %%al, %%rax");
            break;
        case TOKEN_LESS:
            codegen_emit(codegen, "    cmp %%rbx, %%rax");
            codegen_emit(codegen, "    setl %%al");
            codegen_emit(codegen, "    movzb %%al, %%rax");
            break;
        case TOKEN_GREATER:
            codegen_emit(codegen, "    cmp %%rbx, %%rax");
            codegen_emit(codegen, "    setg %%al");
            codegen_emit(codegen, "    movzb %%al, %%rax");
            break;
        default:
            codegen_emit(codegen, "    # Unsupported binary operator: %s", 
                        token_type_to_string(node->data.binary_expr.operator));
            break;
    }
}

void codegen_unary_expression(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_UNARY_EXPR) return;
    
    codegen_expression(codegen, node->data.unary_expr.operand);
    
    switch (node->data.unary_expr.operator) {
        case TOKEN_MINUS:
            codegen_emit(codegen, "    neg %%rax");
            break;
        case TOKEN_NOT:
            codegen_emit(codegen, "    test %%rax, %%rax");
            codegen_emit(codegen, "    setz %%al");
            codegen_emit(codegen, "    movzb %%al, %%rax");
            break;
        default:
            codegen_emit(codegen, "    # Unsupported unary operator: %s", 
                        token_type_to_string(node->data.unary_expr.operator));
            break;
    }
}

void codegen_call_expression(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_CALL_EXPR) return;
    
    // Push arguments in reverse order (right to left)
    for (int i = node->data.call_expr.argument_count - 1; i >= 0; i--) {
        codegen_expression(codegen, node->data.call_expr.arguments[i]);
        codegen_emit(codegen, "    push %%rax");
    }
    
    codegen_emit(codegen, "    call %s", node->data.call_expr.function_name);
    
    // Clean up stack
    if (node->data.call_expr.argument_count > 0) {
        codegen_emit(codegen, "    add $%d, %%rsp", 
                    node->data.call_expr.argument_count * 8);
    }
}

void codegen_identifier(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_IDENTIFIER) return;
    
    // Simplified: assume all identifiers are stored relative to rbp
    codegen_emit(codegen, "    # Load variable %s", node->data.identifier.name);
    codegen_emit(codegen, "    mov -8(%%rbp), %%rax  # Simplified variable access");
}

void codegen_number(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_NUMBER) return;
    
    codegen_emit(codegen, "    mov $%d, %%rax", node->data.number.value);
}

void codegen_string(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_STRING) return;
    
    // Generate string literal (simplified)
    codegen_emit(codegen, "    # String literal: \"%s\"", node->data.string.value);
    codegen_emit(codegen, "    mov $string_literal_%d, %%rax", codegen->label_counter++);
}

void codegen_assignment(CodeGenerator *codegen, ASTNode *node) {
    if (node->type != AST_ASSIGNMENT) return;
    
    // Generate right-hand side
    codegen_expression(codegen, node->data.assignment.value);
    
    // Store in variable (simplified)
    codegen_emit(codegen, "    # Assign to %s", node->data.assignment.variable);
    codegen_emit(codegen, "    mov %%rax, -8(%%rbp)  # Simplified variable assignment");
}