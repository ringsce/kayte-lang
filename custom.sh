#!/bin/bash

# custom.sh — Safe build script for KayteLang projects on macOS and Linux

# Set project file and base name
PROJECT_DIR="projects"
PROJECT_NAME="vb6interpreter"
PROJECT_FILE="$PROJECT_DIR/$PROJECT_NAME.lpr"

# Define target platforms as OS-CPU pairs
TARGET_PLATFORMS=(
  "darwin-aarch64"
  "darwin-x86_64"
  "linux-aarch64" # Added Linux ARM64 target
)

# Arrays to hold paths to architecture-specific executables
DARWIN_BINARIES=()
LINUX_BINARIES=()

# Custom FPC path from Homebrew (or fpcupdeluxe)
# This should point to the 'fpc' wrapper script, which handles cross-compilation flags.
CUSTOM_FPC="/opt/homebrew/bin/fpc" # Standard Homebrew fpc path
FPC_BIN=""

if [[ -x "$CUSTOM_FPC" ]]; then
  echo "✅ Using custom FPC from Homebrew"
  FPC_BIN="$CUSTOM_FPC"
else
  echo "⚠️  Custom FPC not found at $CUSTOM_FPC, falling back to system FPC"
  FPC_BIN=$(which fpc)
fi

echo "--- Cleaning old build files and temporary directories ---"
# Remove universal macOS binary and any previous architecture-specific build directories
rm -f "$UNIVERSAL_OUTPUT_PATH"
for PLATFORM in "${TARGET_PLATFORMS[@]}"; do
  IFS='-' read -r OS_TARGET CPU_TARGET <<< "$PLATFORM"
  rm -rf "${PROJECT_DIR}/build_${OS_TARGET}_${CPU_TARGET}"
done

echo "--- Checking FPC version and config ---"
FPC_CFG=$("$FPC_BIN" -iV 2>/dev/null)
echo "Using Free Pascal $FPC_CFG"

# Loop through each platform to compile and link separately
for PLATFORM in "${TARGET_PLATFORMS[@]}"; do
  IFS='-' read -r OS_TARGET CPU_TARGET <<< "$PLATFORM"

  BUILD_DIR="${PROJECT_DIR}/build_${OS_TARGET}_${CPU_TARGET}"
  EXECUTABLE_NAME="${PROJECT_NAME}_${OS_TARGET}_${CPU_TARGET}"
  OUTPUT_PATH="${BUILD_DIR}/${EXECUTABLE_NAME}"
  mkdir -p "$BUILD_DIR" # Create build directory for this platform

  echo "--- Compiling for ${OS_TARGET}-${CPU_TARGET} ---"

  # Compile without linking (-c), so FPC generates .o and .res files but doesn't call linker
  # -FE"${BUILD_DIR}" ensures output files are in the specific build directory
  "$FPC_BIN" -c -Mdelphi -P"$CPU_TARGET" -T"$OS_TARGET" -FE"${BUILD_DIR}" "$PROJECT_FILE"

  if [ $? -ne 0 ]; then
    echo "❌ ERROR: FPC compilation failed for ${OS_TARGET}-${CPU_TARGET}"
    exit 1
  fi

  echo "--- Performing custom linking for ${OS_TARGET}-${CPU_TARGET} ---"

  # Find the latest generated linkfiles*.res in the current build directory
  LINK_FILES_LIST=$(ls -t "${BUILD_DIR}/linkfiles"*.res 2>/dev/null | head -n 1)

  if [[ -z "$LINK_FILES_LIST" ]]; then
    echo "❌ ERROR: Could not find linkfiles*.res for linking ${OS_TARGET}-${CPU_TARGET}. Make sure FPC output is correct."
    exit 1
  fi

  # Extract the PID part from linkfiles*.res to find the corresponding .res file
  PID=$(basename "$LINK_FILES_LIST" | sed -E 's/linkfiles([0-9]+)\.res/\1/')
  RES_FILE="${BUILD_DIR}/link${PID}.res" # This is the resource file generated by FPC

  LINKER_ARGS=()
  if [[ "$OS_TARGET" == "darwin" ]]; then
    LINKER_COMMAND="/Library/Developer/CommandLineTools/usr/bin/ld"
    LINKER_ARGS+=(
      "-weak_framework" "AppKit"
      "-weak_framework" "UserNotifications"
    )
  elif [[ "$OS_TARGET" == "linux" ]]; then
    LINKER_COMMAND="ld" # Use system ld on Linux
    # Add common Linux linker flags and libraries
    LINKER_ARGS+=(
      # Standard library path for aarch64 on Debian/Ubuntu
      "-L/usr/lib/aarch64-linux-gnu"
      # Link with libc (often implicitly linked, but explicit is safer)
      "-lc"
      # Link with QuickJS library (assuming it's installed and findable)
      "-lquickjs"
      # Add other necessary Linux libraries if your project needs them, e.g., -lpthread
    )
  else
    echo "❌ ERROR: Unsupported OS_TARGET: $OS_TARGET"
    exit 1
  fi

  # Add common linker arguments for all platforms
  LINKER_ARGS+=(
    "-L${BUILD_DIR}" # Look for libraries/objects in the current architecture's build directory
    "-o" "$OUTPUT_PATH" # Output executable name for this architecture
  )

  # Add object files from the linkfiles*.res to the arguments
  while IFS= read -r line; do
    LINKER_ARGS+=("$line")
  done < "$LINK_FILES_LIST"

  # Add the .res file if it exists
  if [[ -f "$RES_FILE" ]]; then
    LINKER_ARGS+=("$RES_FILE")
  fi

  # Execute the linker command
  echo "Running linker for ${OS_TARGET}-${CPU_TARGET}: $LINKER_COMMAND ${LINKER_ARGS[*]}"
  "$LINKER_COMMAND" "${LINKER_ARGS[@]}"

  if [ $? != 0 ]; then
    echo "❌ ERROR: Linking failed for ${OS_TARGET}-${CPU_TARGET}"
    exit 1
  fi

  # Add the successfully built architecture-specific executable to the appropriate array
  if [[ "$OS_TARGET" == "darwin" ]]; then
    DARWIN_BINARIES+=("$OUTPUT_PATH")
  elif [[ "$OS_TARGET" == "linux" ]]; then
    LINUX_BINARIES+=("$OUTPUT_PATH")
  fi

  # Clean up temporary linker files for this architecture
  rm -f "${BUILD_DIR}/linkfiles${PID}.res" "${BUILD_DIR}/link${PID}.res"
done

# --- Final steps after all individual platform builds ---

# Create universal macOS binary with lipo
if [ ${#DARWIN_BINARIES[@]} -gt 0 ]; then
  echo "--- Creating universal macOS binary with lipo ---"
  lipo -create "${DARWIN_BINARIES[@]}" -output "$UNIVERSAL_OUTPUT_PATH"

  if [ $? != 0 ]; then
    echo "❌ ERROR: lipo failed to create universal macOS binary"
    exit 1
  fi
  echo "✅ SUCCESS: Universal macOS binary built -> $UNIVERSAL_OUTPUT_PATH"
else
  echo "⚠️  No macOS binaries built for universal output."
fi

# Report on Linux binaries (they are standalone)
for LINUX_BIN in "${LINUX_BINARIES[@]}"; do
  if [[ -f "$LINUX_BIN" ]]; then
    echo "✅ SUCCESS: Linux binary built -> $LINUX_BIN"
  else
    echo "❌ ERROR: Linux binary build failed -> $LINUX_BIN"
    exit 1
  fi
done

echo "--- Cleaning up architecture-specific build directories ---"
# Clean up all temporary build directories
for PLATFORM in "${TARGET_PLATFORMS[@]}"; do
  IFS='-' read -r OS_TARGET CPU_TARGET <<< "$PLATFORM"
  rm -rf "${PROJECT_DIR}/build_${OS_TARGET}_${CPU_TARGET}"
done

echo "--- Build process finished ---"
