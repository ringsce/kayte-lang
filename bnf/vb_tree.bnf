(*
  BNF (Backus-Naur Form) Definition for the Kayte Language

  This BNF describes the syntax of the Kayte language based on the
  provided Free Pascal Lexer and Parser units (TokenDefs, Lexer, Parser).
  It aims to capture the VB6-like syntax and features implemented.

  Terminal Symbols (Tokens generated by the Lexer):
  Keywords: PRINT, SHOW, IF, THEN, END, REM, TRUE, FALSE, AND, OR, NOT
  Operators: +, -, *, /, =, <, >, <=, >=, <>, & (string concatenation)
  Delimiters: (, ), ,, ., :
  Literals: IntegerLiteral, StringLiteral, BooleanLiteral
  Identifiers: Any valid variable name, form name, or function name.
  Special: EndOfLine, EndOfFile, Comment
*)

(* --- Terminal Symbols (Lexical Tokens) --- *)
<KEYWORD_PRINT>             ::= "PRINT"
<KEYWORD_SHOW>              ::= "SHOW"
<KEYWORD_IF>                ::= "IF"
<KEYWORD_THEN>              ::= "THEN"
<KEYWORD_END>               ::= "END"
<KEYWORD_REM>               ::= "REM"
<BOOLEAN_TRUE>              ::= "TRUE"
<BOOLEAN_FALSE>             ::= "FALSE"
<OPERATOR_PLUS>             ::= "+"
<OPERATOR_MINUS>            ::= "-"
<OPERATOR_MULTIPLY>         ::= "*"
<OPERATOR_DIVIDE>           ::= "/"
<OPERATOR_ASSIGN>           ::= "="
<OPERATOR_LESS>             ::= "<"
<OPERATOR_GREATER>          ::= ">"
<OPERATOR_LESS_EQUAL>       ::= "<="
<OPERATOR_GREATER_EQUAL>    ::= ">="
<OPERATOR_NOT_EQUAL>        ::= "<>"
<OPERATOR_CONCAT>           ::= "&"
<OPERATOR_AND>              ::= "AND"
<OPERATOR_OR>               ::= "OR"
<OPERATOR_NOT>              ::= "NOT"
<PAREN_OPEN>                ::= "("
<PAREN_CLOSE>               ::= ")"
<COLON>                     ::= ":"
<INTEGER_LITERAL>           ::= <digit>+
<STRING_LITERAL>            ::= '"' <char>* '"'
<IDENTIFIER>                ::= <letter> (<letter> | <digit> | '_')*
<END_OF_LINE>               ::= '\n' | '\r\n'
<END_OF_FILE>               ::= <EOF_marker>

(* --- Non-Terminal Symbols (Grammar Rules) --- *)

<program>                   ::= <statement_line>* <END_OF_FILE>

<statement_line>            ::= <statement> (<COLON> <statement>)* <line_terminator>

<line_terminator>           ::= <END_OF_LINE> | <comment> <END_OF_LINE>?

<statement>                 ::= <print_statement>
                              | <show_statement>
                              | <let_statement>
                              | <if_statement>
                              | <end_statement>
                              | <comment>

<comment>                   ::= <KEYWORD_REM> <char_sequence_until_eol>
                              | "'" <char_sequence_until_eol>

<print_statement>           ::= <KEYWORD_PRINT> <expression>

<show_statement>            ::= <KEYWORD_SHOW> <form_name>

<let_statement>             ::= <variable_name> <OPERATOR_ASSIGN> <expression>

<if_statement>              ::= <KEYWORD_IF> <expression> <KEYWORD_THEN> <statement>

<end_statement>             ::= <KEYWORD_END>

(* --- Expressions --- *)
<expression>                ::= <term> ( (<OPERATOR_PLUS> | <OPERATOR_MINUS> | <OPERATOR_CONCAT> | <comparison_operator> | <logical_operator>) <term> )*

<term>                      ::= <factor> ( (<OPERATOR_MULTIPLY> | <OPERATOR_DIVIDE>) <factor> )*

<factor>                    ::= <INTEGER_LITERAL>
                              | <STRING_LITERAL>
                              | <boolean_literal>
                              | <IDENTIFIER> (* Represents a variable reference *)
                              | <PAREN_OPEN> <expression> <PAREN_CLOSE>
                              | <OPERATOR_NOT> <factor> (* Unary NOT *)
                              | <OPERATOR_MINUS> <factor> (* Unary minus *)

<boolean_literal>           ::= <BOOLEAN_TRUE> | <BOOLEAN_FALSE>

<comparison_operator>       ::= <OPERATOR_LESS>
                              | <OPERATOR_GREATER>
                              | <OPERATOR_LESS_EQUAL>
                              | <OPERATOR_GREATER_EQUAL>
                              | <OPERATOR_NOT_EQUAL>
                              | <OPERATOR_ASSIGN> (* Used for equality comparison in VB6 context *)

<logical_operator>          ::= <OPERATOR_AND>
                              | <OPERATOR_OR>

(* --- Identifiers for specific roles --- *)
<variable_name>             ::= <IDENTIFIER>
<form_name>                 ::= <IDENTIFIER>
<function_name>             ::= <IDENTIFIER> (* For event handler names *)

(* --- Basic character definitions (for lexical analysis) --- *)
<digit>                     ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
<letter>                    ::= 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' |
                               'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' |
                               'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' |
                               'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z'
<char>                      ::= <any ASCII character except '"'>
<char_sequence_until_eol>   ::= <any character sequence not including '\n' or '\r'>
