// UKfrmRenderer.pas
// Responsible for rendering KFrm definitions into actual LCL forms and controls.

unit UKfrmRenderer;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, StdCtrls, ExtCtrls, Buttons, // StdCtrls for TButton, TLabel, TEdit; ExtCtrls for TPanel, Buttons for TButton
  Contnrs, // For TObjectList
  UKfrmTypes in '../source/UKfrmTypes.pas', // For TKfrmFormDef, TKfrmControlDef, TKfrmPropertyDef
  UEventRouter; // For TEventRouter

type
type
  TKfrmRenderer = class(TObject)
  private
    // Helper function to apply properties to an LCL control based on TKfrmComponentDef data
    // Changed AControlDef type from TKfrmControlDef to TKfrmComponentDef as per UKfrmTypes hierarchy
    procedure ApplyControlProperties(AControl: TControl; AControlDef: TKfrmComponentDef);
    // Helper function to register events for an LCL control
    // Changed AControlDef type from TKfrmControlDef to TKfrmComponentDef
    procedure RegisterControlEvents(AControl: TControl; AControlDef: TKfrmComponentDef; AEventRouter: TEventRouter);
    // Recursive helper to create controls and their children
    // Changed AControlDef type from TKfrmControlDef to TKfrmComponentDef
    function CreateLCLControl(AControlDef: TKfrmComponentDef; AParent: TWinControl; AEventRouter: TEventRouter): TControl;
  public
    constructor Create;
    destructor Destroy; override;

    // Main function to create and populate an LCL form from a TKfrmFormDef
    // TKfrmFormDef is also defined in UKfrmTypes
    function CreateAndPopulateForm(AFormDef: TKfrmFormDef; AEventRouter: TEventRouter): TForm;
  end;

implementation

{ TKfrmRenderer }

constructor TKfrmRenderer.Create;
begin
  inherited Create;
end;

destructor TKfrmRenderer.Destroy;
begin
  inherited Destroy;
end;

procedure TKfrmRenderer.ApplyControlProperties(AControl: TControl; AControlDef: TKfrmControlDef);
var
  IntValue: Integer;
begin
  if not Assigned(AControl) or not Assigned(AControlDef) then Exit;

  // Apply common properties directly from TKfrmControlDef
  AControl.Name := AControlDef.Name_; // Use Name_ from TKfrmControlDef
  AControl.Left := AControlDef.Left;
  AControl.Top := AControlDef.Top;
  AControl.Width := AControlDef.Width;
  AControl.Height := AControlDef.Height;
  AControl.Visible := AControlDef.Visible;

  // Apply type-specific properties
  case AControlDef.ControlClassType.ToLower of
    'tform': // For forms themselves
      if AControl is TForm then
      begin
        TForm(AControl).Caption := AControlDef.Caption;
        TForm(AControl).Position := AControlDef.Position;
        // Note: Width/Height/Left/Top are already handled by common properties
      end;
    'tbutton', 'tlabel':
      AControl.Caption := AControlDef.Caption;
    'tedit':
      if AControl is TEdit then
      begin
        TEdit(AControl).Text := AControlDef.Text;
        TEdit(AControl).PasswordChar := AControlDef.PasswordChar;
      end;
    // Add more control types and their specific properties here
  end;

  // Example for TWinControl.Align (if you want to support it via a generic property or specific field)
  // This would require adding an 'Align' property to TKfrmControlDef or parsing from a generic property list.
  // For now, it's not directly included in the TKfrmControlDef structure you provided.
  // If you add it to TKfrmControlDef, you'd do:
  (*
  if AControl is TWinControl then
  begin
    case AControlDef.Align.ToLower of // Assuming Align is a string property in TKfrmControlDef
      'alnone': TWinControl(AControl).Align := alNone;
      'alclient': TWinControl(AControl).Align := alClient;
      // ... etc.
    end;
  end;
  *)
end;

procedure TKfrmRenderer.RegisterControlEvents(AControl: TControl; AControlDef: TKfrmControlDef; AEventRouter: TEventRouter);
begin
  if not Assigned(AControl) or not Assigned(AControlDef) or not Assigned(AEventRouter) then Exit;

  // Register OnClick if specified
  if AControlDef.OnClickHandlerName <> '' then
  begin
    if AControl is TButton then
      TButton(AControl).OnClick := AEventRouter.RegisterOnClickHandler(AControl, AControlDef.OnClickHandlerName)
    else if AControl is TLabel then // Labels typically don't have OnClick unless made interactive
      WriteLn(SysUtils.Format('UKfrmRenderer: Warning: OnClick specified for TLabel "%s". TLabel does not have a direct OnClick event unless made interactive.', [AControl.Name]))
    else if AControl is TEdit then // Edits typically don't use OnClick for primary interaction
      WriteLn(SysUtils.Format('UKfrmRenderer: Warning: OnClick specified for TEdit "%s". Consider other events like OnChange or OnEnter for primary interaction.', [AControl.Name]))
    else
      WriteLn(SysUtils.Format('UKfrmRenderer: Warning: OnClick specified for unsupported control type "%s" (Name: "%s").', [AControl.ClassName, AControl.Name]));
  end;

  // Add more event types (e.g., OnChange, OnKeyDown) here if your TKfrmControlDef includes them
  // For example: if AControlDef.OnChangeHandlerName <> '' then ...
end;


function TKfrmRenderer.CreateLCLControl(AControlDef: TKfrmControlDef; AParent: TWinControl; AEventRouter: TEventRouter): TControl;
var
  LCLControl: TControl;
  ChildControlDef: TKfrmControlDef;
  I: Integer;
begin
  LCLControl := nil;

  // Create the LCL control based on ControlClassType
  case AControlDef.ControlClassType.ToLower of
    'tform':
      // Forms are handled by CreateAndPopulateForm directly, but this case is here for completeness
      // if you were to create sub-forms dynamically.
      LCLControl := TForm.Create(AParent);
    'tbutton':
      LCLControl := TButton.Create(AParent);
    'tlabel':
      LCLControl := TLabel.Create(AParent);
    'tedit':
      LCLControl := TEdit.Create(AParent);
    'tpanel':
      LCLControl := TPanel.Create(AParent); // Requires ExtCtrls
    // Add more control types as needed (e.g., TMemo, TListBox, TCheckBox, TRadioButton)
    else
      WriteLn(SysUtils.Format('UKfrmRenderer: Error: Unknown control type "%s". Cannot create control.', [AControlDef.ControlClassType]));
      Exit(nil); // Exit if control type is unknown
  end;

  // Set parent if it's not a top-level form
  if Assigned(AParent) then
    LCLControl.Parent := AParent; // TControl.Parent property is TWinControl

  // Apply properties
  ApplyControlProperties(LCLControl, AControlDef);

  // Register events
  RegisterControlEvents(LCLControl, AControlDef, AEventRouter);

  // Recursively create and populate child controls (if any)
  // Note: TKfrmControlDef does not have a 'Children' list in your latest UKfrmTypes.pas.
  // If controls can be nested, you'll need to add 'Children: TObjectList;' to TKfrmControlDef
  // and modify TKfrmFormDef.Controls to contain these TKfrmControlDef.
  // Assuming for now that only forms have a 'Controls' list.
  Result := LCLControl;
end;

function TKfrmRenderer.CreateAndPopulateForm(AFormDef: TKfrmFormDef; AEventRouter: TEventRouter): TForm;
var
  NewForm: TForm;
  ControlDef: TKfrmControlDef;
  I: Integer;
begin
  Result := nil;
  if not Assigned(AFormDef) then Exit;

  // Create the form instance
  NewForm := TForm.Create(Application); // Application is the owner for top-level forms
  NewForm.Name := AFormDef.Name_; // Set the form's name early for debugging/lookup

  // Apply form-specific properties (FormDef is a TKfrmFormDef, which has common properties)
  ApplyControlProperties(NewForm, AFormDef); // TKfrmFormDef inherits from TObject, not TKfrmControlDef, so pass it directly

  // Register form events (if any, e.g., OnClose, OnShow)
  // Assuming TKfrmFormDef has an OnClickHandlerName for the form itself if needed
  RegisterControlEvents(NewForm, AFormDef, AEventRouter);

  // Create and populate controls on the form
  if Assigned(AFormDef.Controls) then
  begin
    for I := 0 to AFormDef.Controls.Count - 1 do
    begin
      ControlDef := TKfrmControlDef(AFormDef.Controls.Items[I]);
      CreateLCLControl(ControlDef, NewForm, AEventRouter); // Pass NewForm as parent
    end;
  end;

  Result := NewForm;
end;

end.

